" Malcolm Ramsay  .vimrc
"
"General {{{

if !has('nvim')
    set encoding=utf-8
endif

scriptencoding utf-8

source $HOME/dotfiles/vim/plugins.vim   " load plugins

set autoread                            " Vim automatically reads changes to a file

augroup vimrc
    autocmd!
    autocmd BufEnter * :checktime       " Reload changes on FocusGained
augroup END

filetype plugin indent on               " load filetype specific indent and plugin files

""" Python configuration
let g:loaded_python_provider = 1

if isdirectory($HOME.'/.miniconda/envs/neovim')
    let g:python3_host_prog = $HOME.'/.miniconda/envs/neovim/bin/python'
endif

let g:email = 'malramsay64@gmail.com'
let g:username = 'Malcolm Ramsay'

" Use existing neovim session if opening from terminal
if has('nvim') && executable('nvr')
  let $VISUAL = "nvr -cc split --remote-wait +'set bufhidden=wipe'"
endif

if exists('&belloff')
    set belloff=all                     " Turn off all bells
endif

"}}}
"Colours {{{

syntax enable                           " enable syntax processing

" Enable truecolour support in neovim >= 0.1.5 || vim >= 7.4.1799
if has('termguicolors')
    set termguicolors
endif

" Load colourscheme in vim with tmux
if !has('nvim')
    set t_8b=[48;2;%lu;%lu;%lum
    set t_8f=[38;2;%lu;%lu;%lum
endif

""" Configure Colourscheme
let g:quantum_italics=1

" Colourscheme override
augroup colourOverride
   autocmd!
   autocmd ColorScheme * highlight Conceal guibg=NONE
   autocmd Colorscheme * highlight SpellBad guibg=NONE
   autocmd Colorscheme * highlight SpellCap guibg=NONE
   autocmd Colorscheme * highlight SpellLocal guibg=NONE
   autocmd Colorscheme * highlight SpellRare guibg=NONE
   autocmd Colorscheme * highlight CursorLineNr guibg=NONE
augroup END

set background=dark " for the dark version
colorscheme quantum

" }}}
"Spaces and Tabs {{{

set tabstop=4           " number of visual spaces per TAB
set softtabstop=4       " number of spaces inserted upon TAB
set shiftwidth=4        " autoindent amount when using cindent
set expandtab           " TAB inserts softtabstop spaces

set autoindent          " copy indentation from previous line
set nosmartindent       " inserts extra indentation in some cases

" Remove trailing whitespace from file and return cursor to current position
function! StripTrailingWhitespaces()
    let l:pos = winsaveview()
    execute('%s/\s\+$//e')
    call winrestview(l:pos)
endfun

nnoremap <Space>zz :call StripTrailingWhitespaces()<CR>


"}}}
"UI Config {{{


" The combination of relative number and number gives the absolute line
" number for the current line and relative numbers for all others
set relativenumber                      " show relative line numbers
set number                              " show line numbers
set scrolloff=5                         " 5 lines above and below cursor when scrolling
set wildmenu                            " visual autocomplete for command
set wildmode=longest:full,full          " Complete to longest matching text then first match. Like shell completion
set lazyredraw                          " redraw only when need to
set hidden                              " allows you to hide buffers with unsaved changes without being prompted
set noshowmatch                         " highlight matching parenthesis/bracket/brace
set laststatus=2                        " Display statusline
set splitright                          " open splits by default to the right
set nosplitbelow                        " open splits above current
set formatoptions+=n                    " smart auto-indenting inside numbered lists
set formatoptions+=j                    " smart comment joining
set nojoinspaces                        " don't autoinsert two spaces after '.', '?', '!' for join command
set textwidth=88                        " Textwidth is 88 columns

" common mistypings of exit and save
cabbrev W w
cabbrev Q q
cabbrev Wq wq
cabbrev WQ wq

" Unicode UI elements
if has('linebreak')
  let &showbreak='‚§∑ '          " ARROW POINTING DOWNWARDS THEN CURVING RIGHTWARDS (U+2937, UTF-8: E2 A4 B7)
endif
set fillchars=vert:‚îÇ           " BOX DRAWINGS LIGHT VERTICAL (U+2502, UTF-8: E2 94 82)

set list                       " we want to show whitespace elements
set listchars=tab:‚ñ∂‚Äí
set listchars+=nbsp:‚ê£
set listchars+=extends:¬ª       " RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK (U+00BB, UTF-8: C2 BB)
set listchars+=precedes:¬´      " LEFT-POINTING DOUBLE ANGLE QUOTATION MARK (U+00AB, UTF-8: C2 AB)
set listchars+=trail:‚Ä¢         " BULLET (U+2022, UTF-8: E2 80 A2)

"" Movement
set backspace=eol,start,indent  " backspace deletes newlines
set whichwrap+=<,>,h,l,[,]      " left right wraps to next/previous lines

" Movement between splits
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
inoremap <C-h> <C-\><C-N><C-w>h
inoremap <C-j> <C-\><C-N><C-w>j
inoremap <C-k> <C-\><C-N><C-w>k
inoremap <C-l> <C-\><C-N><C-w>l
if has('nvim')
  tnoremap <C-h> <C-\><C-N><C-w>h
  tnoremap <C-j> <C-\><C-N><C-w>j
  tnoremap <C-k> <C-\><C-N><C-w>k
  tnoremap <C-l> <C-\><C-N><C-w>l
endif

" Consistency with yank
nnoremap Y y$

augroup gopass_security
    " Don't backup gopass files.
    autocmd BufNewFile,BufRead /dev/shm/gopass.* setlocal noswapfile nobackup noundofile
augroup end

"}}}
" Custom Shortcuts {{{

" jk is escape
inoremap jk <esc>
inoremap jK <esc>
inoremap JK <esc>
inoremap Jk <esc>

" leader is <space>
let g:mapleader="\<space>"

" go to next split
nnoremap <Leader>w <c-w>w
" Turn off search highlighting
nnoremap <Leader>h :nohlsearch<CR>
" Reload vimrc
nnoremap <Leader>r :source $MYVIMRC<CR>
" Edit vimrc
nnoremap <Leader>er :edit $MYVIMRC<CR>
" Edit plugins
nnoremap <Leader>ep :edit $DOTFILES/vim/plugins.vim<CR>
" Edit UnltiSnips
nnoremap <Leader>es :UltiSnipsEdit<CR>
" Edit in ftplugin directory
nnoremap <Leader>ef :edit ~/.vim/ftplugin<CR>
" Edit in tmux config
nnoremap <Leader>et :edit ~/.tmux.conf<CR>
" Edit bashrc
nnoremap <Leader>eb :edit ~/.bashrc<CR>
" Edit zshrc
nnoremap <Leader>ez :edit ~/.zshrc<CR>
" Edit vim direcotry
"nnoremap <Leader>ed :edit $DOTFILES/vim/<CR>
" Edit denite config
nnoremap <Leader>ed :edit $DOTFILES/vim/denite.vim<CR>
" <C-s> will correct previous spelling mistake and set undo point
nnoremap <silent> <C-s> :call spelling#fix_previous()<CR>
inoremap <silent> <C-s> <C-g>u<C-o>:call spelling#fix_previous()<CR>
" navigate between tabs
nnoremap ]w :tabnext<CR>
nnoremap [w :tabprev<CR>
" Remap for digraphs
inoremap <C-y> <C-k>

" Open last buffer
nnoremap <leader><leader> <C-^>

" Shortcut for saving file as root
" cmap w!! w !sudo tee > /dev/null %
cmap w!! w suda://%

" Faster window resizing
nnoremap <C-w>- :5wincmd -<CR>
nnoremap <C-w>= :5wincmd +<CR>
nnoremap <C-w>+ :wincmd =<CR>
nnoremap <leader>vj :5wincmd +<CR>
nnoremap <leader>vk :5wincmd -<CR>
nnoremap <space>w= :wincmd =<CR>

"}}}
"Searching {{{

set incsearch " search as characters entered
set hlsearch  " highlight matches
set ignorecase " ignore case when searching
set smartcase " overrides ignorecase if uppercase characters in search query

set magic     " regular expressions

" Use ripgrep for search if available
if executable('rg')
    set grepprg=rg\ --vimgrep\ --no-heading
    set grepformat=%f:%l:%c:%m,%f:%l:%m
endif

"}}}
"Folding {{{

set foldenable         " enable folding
set foldlevelstart=5   " have all levels open by default
set foldnestmax=2      " Maximum number of nested folds
set foldmethod=syntax  " fold based on indent

set modelines=1        " last line of file is checked to run as a command

"}}}
"Backups {{{

if exists('$SUDO_USER')
    set nobackup        " Don't write backups for root files
    set nowritebackup   " No backups when root user
    set noswapfile      " no swap files for root user

    if has('persistent_undo')
        set noundofile  " no undo for root user
    endif
else
    set backup          " Performs backups
    set writebackup     " perform backup
    set backupdir=~/.vim-tmp,~/.tmp,. " Backup directories

    set directory=~/.vim-tmp/swap//,~/.tmp/swap//,. " Directories for swap files

    if has('persistent_undo')
        set undofile
        set undodir=~/.vim-tmp/undo     "undo directory
        set undodir+=~/.tmp/undo
        set undodir+=.
    endif
endif

"}}}
"Spelling and Files{{{

set spelllang=en_au             " spelling language is English Australian
set fileformats=unix,mac,dos    " default line ending is unix
set nospell                     " Spelling is off by default, but is turned on for many filetypes

" set filetype defaults
augroup filetypes
    autocmd!
    if has('nvim')
        autocmd TermOpen * setlocal nonumber norelativenumber
    endif
augroup END

"}}}
" Plugin Configuration {{{

" fzf {{{
"
" This is the default extra key bindings
let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-x': 'split',
  \ 'ctrl-v': 'vsplit' }

" Default fzf layout
" - down / up / left / right
let g:fzf_layout = { 'down': '~40%' }

" In Neovim, you can set up fzf window using a Vim command
let g:fzf_layout = { 'window': 'belowright 10split enew' }

" Customize fzf colours to match your colour scheme
let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }

" Enable per-command history.
" CTRL-N and CTRL-P will be automatically bound to next-history and
" previous-history instead of down and up. If you don't like the change,
" explicitly bind the keys to down and up in your $FZF_DEFAULT_OPTS.
let g:fzf_history_dir = '~/.local/share/fzf-history'

" [Buffers] Jump to the existing window if possible
let g:fzf_buffers_jump = 1

" [[B]Commits] Customize the options used by 'git log':
let g:fzf_commits_log_options = '--graph --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr"'

" [Tags] Command to generate tags file
let g:fzf_tags_command = 'ctags -R'

" [Commands] --expect expression for directly executing the command
let g:fzf_commands_expect = 'alt-enter,ctrl-x'

nnoremap <silent> <C-p> :<C-u>GFiles<CR>
nnoremap <silent> <C-f> :<C-u>Files<CR>
nnoremap <Leader>gf :<C-u>Commits<CR>
nnoremap <leader>b :<C-U>Buffers<CR>

" }}}
" fugitive {{{

nnoremap <Leader>gs :Gstatus<CR>
nnoremap <Leader>gc :Gcommit<CR>

" }}}
" ale {{{

let g:ale_sign_column_always = 1
let g:ale_sign_error = '>>'
let g:ale_sign_warning = '--'

let g:ale_linter_aliases = {'pandoc': ['markdown']}

let g:ale_linters = {
      \ 'python': ['flake8', 'pylint', 'mypy', 'pydocstyle'],
      \ 'c++': ['clangd'],
      \ 'cpp': ['clangd'],
      \ 'c': ['clangd'],
      \ 'rust': ['cargo'],
      \ }

let g:ale_rust_check_all_targets = 1
let g:ale_rust_cargo_use_clippy = executable('cargo-clippy')
let g:ale_rust_cargo_clippy_options = '--all-features'


let g:ale_python_pylint_change_directory = 0
let g:ale_lint_on_text_changed = 1
let g:ale_lint_delay = 500
let g:ale_lint_on_save = 1

let g:ale_fixers = {
      \ '*': ['remove_trailing_lines', 'trim_whitespace'],
      \ 'python': ['isort', 'black'],
      \ 'yaml': ['prettier', 'remove_trailing_lines', 'trim_whitespace'],
      \ 'markdown': ['prettier', 'remove_trailing_lines', 'trim_whitespace'],
      \ 'cpp': ['clang-format', 'remove_trailing_lines', 'trim_whitespace'],
      \ 'rust': ['rustfmt'],
      \ }

let g:ale_fix_on_save = 1

nnoremap ]v :ALENextWrap<CR>
nnoremap [v :ALEPreviousWrap<CR>

" }}}
" ultisnips {{{

let g:UltiSnipsExpandTrigger='<C-f>'
let g:UltiSnipsJumpForwardTrigger='<tab>'
let g:UltiSnipsJumpBackwardTrigger='<S-tab>'
let g:UltiSnipsEditSplit='horizontal'

" Set the documentation style for the snippets
let g:ultisnips_python_style='google'

" Configuration settings
let g:snips_author = 'Malcolm Ramsay'
let g:snips_email = 'malramsay64@gmail.com'
let g:snips_github = 'https://github.com/malramsay64'

" Directories
let g:UltiSnipsSnippetsDir = '~/.vim/UltiSnips'

" }}}
" vimtex {{{

let g:tex_flavor='latex'

" enable vimtex
let g:vimtex_enabled = 1

" Folding options
let g:vimtex_fold_enabled = 1
let g:vimtex_fold_env_whitelist = ['figure', 'table']

" latexmk options
let g:vimtex_latexmk_enabled = 1
let g:vimtex_latexmk_build_dir = 'output'

" }}}
" incsearch {{{

set hlsearch
let g:incsearch#auto_nohlsearch = 1
map n  <Plug>(incsearch-nohl-n)
map N  <Plug>(incsearch-nohl-N)
map *  <Plug>(incsearch-nohl-*)
map #  <Plug>(incsearch-nohl-#)
map g* <Plug>(incsearch-nohl-g*)
map g# <Plug>(incsearch-nohl-g#)

" }}}
" grammarous {{{

let g:grammarous#use_vim_spelllang = 1
let g:grammarous#move_to_first_error = 0
let g:grammarous#default_lang = 'en_au'

nnoremap <leader>gg :GrammarousCheck<CR>
nnoremap <leader>gr :GrammarousReset<CR>

" }}}
" template {{{

let g:templates_directory = [$DOTFILES.'/vim/templates']

let g:templates_user_variables = [
            \ ['DIRECTORY', 'GetDirectoryName'],
            \ ]

function! GetDirectoryName()
    " Expand to full path, remove the filename, then get the folder
    return expand('%:p:h:t')
endfunction

" }}}
" thesaurus_query {{{

nnoremap <Leader>y :ThesaurusQueryReplaceCurrentWord<CR>

" }}}
" undotree {{{

noremap <leader>u :UndotreeToggle<CR>

" }}}
"  Scalpel {{{

nmap <Leader>s <Plug>(Scalpel)

"  }}}
" Tagbar {{{

nnoremap <Leader>t :TagbarToggle<CR>

" }}}
" project-log {{{

let g:project_home = $HOME.'/Projects/'
let g:project_log#logbooks = [
            \ g:project_home.'Dynamics/logbook',
            \ g:project_home.'Crystal_Melting/logbook',
            \ g:project_home.'Machine_Learning/logbook',
            \ g:project_home.'Seminars',
            \ $HOME.'/Documents/diary'
            \ ]
let g:project_log#log_level = 'DEBUG'

"}}}
" pandoc {{{

let g:pandoc#syntax#conceal#use = 1
let g:pandoc#syntax#conceal#urls = 1
let g:pandoc#syntax#codeblocks#embeds#langs = ["python", "rust"]
let g:pandoc#modules#disabled = ["chdir", "folding", "keyboard", "formatting"]
let g:pandoc#filetypes#handled = ["pandoc", "markdown"]
let g:pandoc#filetypes#pandoc_markdown = 1
let g:pandoc#formatting#mode='ha'
let g:pandoc#hypertext#open_editable_alternates=1
let g:pandoc#hypertext#use_default_mappings = 1
let g:pandoc#command#autoexec_command = "Pandoc! pdf"

let g:pandoc#biblio#bibs = [$HOME."/Downloads/PhD.bib"]
let g:pandoc#biblio#use_bibtool = 2

" }}}
" lightline {{{
"
" Configuration for ale
let g:lightline = {}

let g:lightline#ale#indicator_checking = "\uf110 "
let g:lightline#ale#indicator_warnings = "\uf071 "
let g:lightline#ale#indicator_errors = "\uf05e "
let g:lightline#ale#indicator_ok = "\uf00c "

let g:lightline.component_expand = {
      \  'linter_checking': 'lightline#ale#checking',
      \  'linter_warnings': 'lightline#ale#warnings',
      \  'linter_errors': 'lightline#ale#errors',
      \  'linter_ok': 'lightline#ale#ok',
      \ }
let g:lightline.component_type = {
      \     'linter_checking': 'left',
      \     'linter_warnings': 'warning',
      \     'linter_errors': 'error',
      \     'linter_ok': 'left',
      \ }
let g:lightline.component_function = {
      \   'gitbranch': 'fugitive#head',
      \   'wordcount': 'wordCount#WordCount',
      \ }
let g:lightline.component =  {
      \   'lineinfo': '%3l %-2v',
      \ }

let g:lightline.colorscheme  = 'quantum'
let g:lightline.active = {
      \   'left': [ [ 'mode', 'paste' ],
      \             [ 'gitbranch', 'readonly', 'filename', 'modified' ] ],
      \   'right': [ [ 'linter_checking', 'linter_errors', 'linter_warnings', 'linter_ok' ],
      \             [ 'lineinfo' ], [ 'wordcount', 'percent' ], [ 'filetype', 'fileformat' ] ]
      \ }

" }}}
" wordcount {{{

let g:wc_conservative_update = 1

"  }}}
" nerdcommenter {{{

" Add spaces after comment delimiters by default
let g:NERDSpaceDelims = 1

" Use compact syntax for prettified multi-line comments
let g:NERDCompactSexyComs = 1

nnoremap <C-/> <plug>NERDCommenterToggle
vnoremap <C-/> <plug>NERDCommenterToggle

" }}}
" Goyo {{{
"
let g:goyo_width=88

function! s:goyo_enter()
  ALEDisableBuffer
  let b:ale_fix_on_save = 0
  call lightline#disable()
  set noshowmode
  set noshowcmd
  set scrolloff=999
  if has('nvim')
      call ncm2#disable_for_buffer()
  endif
  silent !tmux set status off
  silent !tmux list-panes -F '\#F' | grep -q Z; or tmux resize-pane -Z
endfunction

function! s:goyo_leave()
  silent !tmux set status on
  silent !tmux list-panes -F '\#F' | grep -q Z; and tmux resize-pane -Z
  call lightline#enable()
  set showmode
  set showcmd
  set scrolloff=5
  ALEEnableBuffer
  let b:ale_fix_on_save = 1
  if has('nvim')
      call ncm2#enable_for_buffer()
  endif
endfunction

autocmd! User GoyoEnter nested call <SID>goyo_enter()
autocmd! User GoyoLeave nested call <SID>goyo_leave()

nnoremap <space>gg :Goyo<CR>

" }}}
" netrw {{{

let g:netrw_banner = 0

" }}}
" Polyglot  {{{
let g:python_highlight_all = 1

let g:polyglot_disabled = ['markdown']

" }}}
" ncm2 {{{

set completeopt=noinsert,menuone,noselect

let g:ncm2#matcher = 'substrfuzzy'

" Increse the delay before the popup appears
let g:ncm2#popup_delat = 250

augroup ncm2
  autocmd!
  autocmd BufRead * call ncm2#enable_for_buffer()
augroup END

" suppress the annoying 'match x of y', 'The only match' and 'Pattern not
" found' messages
set shortmess+=c

" When the <Enter> key is pressed while the popup menu is visible, it only
" hides the menu. Use this mapping to close the menu and also start a new
" line.
inoremap <expr> <CR> (pumvisible() ? "\<c-y>\<cr>" : "\<CR>")

let g:ncm2_pyclang#library_path = '/usr/lib64/libclang.so.7'
" a list of relative paths looking for .clang_complete
let g:ncm2_pyclang#args_file_path = ['.clang_complete']
let g:ncm2_pyclang#clang_path = 'clang++'

call ncm2#override_source('LanguageClient_cpp', {'enable': 0})

let g:float_preview#docked = 1

let g:markdown_fenced_languages=["python"]

augroup my_cm_setup
    autocmd!
    autocmd Filetype markdown,pandoc call ncm2#register_source({
      \ 'name': 'pandoc',
      \ 'priority': 8,
      \ 'scope': ['markdown', 'pandoc'],
      \ 'mark': 'bib',
      \ 'word_pattern': '\w+',
      \ 'complete_pattern': ['@'],
      \ 'on_complete': ['ncm2#on_complete#omni', 'pandoc#completion#Complete'],
      \ })
augroup END

" }}}
" gitgutter {{{

" Cycle changes in all buffers
function! NextHunkAllBuffers()
  let line = line('.')
  GitGutterNextHunk
  if line('.') != line
    return
  endif

  let bufnr = bufnr('')
  while 1
    bnext
    if bufnr('') == bufnr
      return
    endif
    if !empty(GitGutterGetHunks())
      normal! 1G
      GitGutterNextHunk
      return
    endif
  endwhile
endfunction

function! PrevHunkAllBuffers()
  let line = line('.')
  GitGutterPrevHunk
  if line('.') != line
    return
  endif

  let bufnr = bufnr('')
  while 1
    bprevious
    if bufnr('') == bufnr
      return
    endif
    if !empty(GitGutterGetHunks())
      normal! G
      GitGutterPrevHunk
      return
    endif
  endwhile
endfunction

nnoremap <silent> ]c :call NextHunkAllBuffers()<CR>
nnoremap <silent> [c :call PrevHunkAllBuffers()<CR>

" }}}
" neoterm {{{

let g:neoterm_autoinsert = 1
let g:neoterm_default_mod = 'keepalt'
let g:neoterm_autoscroll = 1

" }}} Language client neovim {{{

let g:LanguageClient_serverCommands = {
  \ 'cpp': ['clangd'],
  \ 'rust': ['rls'],
  \ }

function! SetLSPShortcuts()
  nnoremap <leader>ld :call LanguageClient#textDocument_definition()<CR>
  nnoremap <leader>lr :call LanguageClient#textDocument_rename()<CR>
  nnoremap <leader>lf :call LanguageClient#textDocument_formatting()<CR>
  nnoremap <leader>lt :call LanguageClient#textDocument_typeDefinition()<CR>
  nnoremap <leader>lx :call LanguageClient#textDocument_references()<CR>
  nnoremap <leader>la :call LanguageClient_workspace_applyEdit()<CR>
  nnoremap <leader>lc :call LanguageClient#textDocument_completion()<CR>
  nnoremap <leader>lh :call LanguageClient#textDocument_hover()<CR>
  nnoremap <leader>ls :call LanguageClient_textDocument_documentSymbol()<CR>
  nnoremap <leader>lm :call LanguageClient_contextMenu()<CR>
endfunction()

augroup LSP
  autocmd!
  autocmd FileType cpp,c,rust call SetLSPShortcuts()
augroup END

" }}}
" My Notes {{{

let g:notes_dir = '~/Documents/PhD/notes'
nnoremap <silent> <space>wn :execute 'lcd '.fnameescape(g:notes_dir).' <bar> edit index.md'<CR>
nnoremap gf :e <cfile><CR>

" }}}
" Vimwiki {{{

nmap <Leader>wj <Plug>VimwikiDiaryPrevDay
nmap <Leader>wk <Plug>VimwikiDiaryNextDay

let g:vimwiki_folding = 'syntax'
let g:vimwiki_ext2syntax = {
      \'.md': 'markdown',
      \ '.mkd': 'markdown',
      \ '.wiki': 'media'
      \}
let g:vimwiki_global_ext = 0

" Wiki settings
let s:wiki_default = {}
let s:wiki_default.auto_export = 0
let s:wiki_default.auto_toc = 1
let s:wiki_default.nested_syntaxes = {'python': 'python', 'c++': 'cpp', 'sh': 'sh'}
let s:wiki_default.syntax = 'markdown'
let s:wiki_default.ext = '.md'

let s:home_wiki = copy(s:wiki_default)
let s:home_wiki.path = '~/Documents/notes/personal/'
let s:home_wiki.diary_rel_path = 'diary/'
let s:home_wiki.path_html = '~/Documents/notes/html/personal/'

let s:phd_wiki = copy(s:wiki_default)
let s:phd_wiki.path = '~/Documents/notes/PhD/'
let s:phd_wiki.diary_rel_path = 'logbook/'
let s:phd_wiki.diary_index = 'index'
let s:phd_wiki.diary_header = 'PhD Logbook'
let s:phd_wiki.path_html = '~/Documents/notes/html/PhD/'
let s:phd_wiki.auto_export = 0
let s:phd_wiki.html_template = '~/Documents/notes/template.html'
let s:phd_wiki.template_path = '~/Documents/notes/'
let s:phd_wiki.template_default = 'template'
let s:phd_wiki.template_ext = '.html'

let g:vimwiki_list = [s:home_wiki, s:phd_wiki]

" Custom image handler for html
function! VimwikiWikiIncludeHandler(value)
    let l:str = a:value

    " complete URL
    let l:url_0 = matchstr(l:str, vimwiki#vars#get_global('rxWikiInclMatchUrl'))
    " URL parts
    let l:link_infos = vimwiki#base#resolve_link(l:url_0)
    let l:descr = matchstr(l:str, vimwiki#html#incl_match_arg(1))
    let l:verbatim_str = matchstr(l:str, vimwiki#html#incl_match_arg(2))

    let l:link_infos = vimwiki#base#resolve_link(l:url_0)

    let l:url = l:link_infos.filename

    let l:url = escape(l:url, '#')

    if fnamemodify(l:url, ':e') =~? 'pdf'
        let l:line = '<figure>'.
                    \ '<object data='.l:url." type='application/pdf' height=100% width=100%></object>".
                    \'<figcaption>Fig: '.l:descr.'</figcaption>'.
                    \'</figure>'
    else
        let l:line = '<figure>'.
                    \ vimwiki#html#linkify_image(l:url, l:descr, l:verbatim_str).
                    \'<figcaption>Fig: '.l:descr.'</figcaption>'.
                    \'</figure>'
    endif

    " Return the empty string when unable to process link
    return l:line
endfunction


"}}}
" vim: foldmethod=marker foldlevel=0 filetype=vim tabstop=2 softtabstop=2 shiftwidth=2
